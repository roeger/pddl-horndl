(define (domain elevators)
(:constants
  pass_r pass_u pass_x pass_n pass_w pass_g pass_k pass_y pass_d pass_l a b c e f h i j m o p q s t v - object)
(:predicates
  (passenger ?p - object)
  (boarded ?p - object)
  (served ?p - object)
  (floor ?p - object)
  (origin ?p ?f - object)
  (destin ?p ?f - object)
  (liftat ?f - object)
  (next ?f1 ?f2 - object)
  (DATALOG_PASSENGER ?x0 - object)
  (DATALOG_FLOOR ?x0 - object)
  (DATALOG_QUERY0 ?x0 ?x1 - object)
  (DATALOG_INCONSISTENT)
  (AUX0 ?y0 - object ?y1 - object ?y2 - object)
  (AUX1 ?y0 - object)
  (AUX2 ?x - object))
(:derived (DATALOG_QUERY0 ?x0 ?x1 - object)
          (and (boarded ?x1) (destin ?x1 ?x0)))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (or (exists (?y0 - object) (destin ?x0 ?y0)) (exists (?y0 - object) (origin ?x0 ?y0)) (boarded ?x0) (passenger ?x0) (served ?x0)))
(:derived (DATALOG_FLOOR ?x0 - object)
          (or (exists (?y0 - object) (destin ?y0 ?x0)) (exists (?y0 - object) (origin ?y0 ?x0)) (floor ?x0) (liftat ?x0)))
(:derived (DATALOG_INCONSISTENT)
          (or (exists (?y0 ?y1 ?y2 - object) (AUX0 ?y0 ?y1 ?y2)) (exists (?y0 - object) (AUX1 ?y0))))
(:derived (AUX0 ?y0 - object ?y1 - object ?y2 - object)
          (and (next ?y0 ?y1) (next ?y0 ?y2) (not (= ?y1 ?y2))))
(:derived (AUX1 ?y0 - object)
          (and (DATALOG_FLOOR ?y0) (DATALOG_PASSENGER ?y0)))
(:derived (AUX2 ?x - object)
          (or (served ?x) (not (DATALOG_PASSENGER ?x))))
(:action stop
  :parameters (?p ?f - object)
  :precondition (and (DATALOG_PASSENGER ?p) (liftat ?f) (not (DATALOG_INCONSISTENT)))
  :effect (and (when (and (origin ?p ?f) (not (boarded ?p)) (not (served ?p))) (boarded ?p)) (when (DATALOG_QUERY0 ?f ?p) (and (served ?p) (not (boarded ?p))))))
(:action moveUp
  :parameters (?f1 ?f2 - object)
  :precondition (and (liftat ?f1) (next ?f1 ?f2) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
(:action moveDown
  :parameters (?f1 ?f2 - object)
  :precondition (and (liftat ?f1) (next ?f2 ?f1) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
)