(define (domain elevators)
(:constants
  pass_af pass_az pass_au pass_ac pass_ai pass_ab pass_an pass_ah pass_ak pass_ay aa ad ae ag aj al am ao ap aq ar as at av aw ax ba - object)
(:predicates
  (passenger ?p - object)
  (boarded ?p - object)
  (served ?p - object)
  (floor ?p - object)
  (origin ?p ?f - object)
  (destin ?p ?f - object)
  (liftat ?f - object)
  (next ?f1 ?f2 - object)
  (DATALOG_QUERY0 ?x0 ?x1 - object)
  (DATALOG_PASSENGER ?x0 - object)
  (DATALOG_FLOOR ?x0 - object)
  (DATALOG_INCONSISTENT ))
(:derived (DATALOG_QUERY0 ?x0 ?x1 - object)
          (and (boarded ?x1) (destin ?x1 ?x0)))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (passenger ?x0))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (boarded ?x0))
(:derived (DATALOG_FLOOR ?x0 - object)
          (floor ?x0))
(:derived (DATALOG_FLOOR ?x0 - object)
          (liftat ?x0))
(:derived (DATALOG_INCONSISTENT )
          (exists (?y0 ?y1 ?y2 - object) (and (next ?y0 ?y1) (next ?y0 ?y2) (not (= ?y1 ?y2)))))
(:derived (DATALOG_INCONSISTENT )
          (exists (?y0 - object) (and (DATALOG_FLOOR ?y0) (DATALOG_PASSENGER ?y0))))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (served ?x0))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (exists (?y0 - object) (destin ?x0 ?y0)))
(:derived (DATALOG_PASSENGER ?x0 - object)
          (exists (?y0 - object) (origin ?x0 ?y0)))
(:derived (DATALOG_FLOOR ?x0 - object)
          (exists (?y0 - object) (origin ?y0 ?x0)))
(:derived (DATALOG_FLOOR ?x0 - object)
          (exists (?y0 - object) (destin ?y0 ?x0)))
(:action stop
  :parameters (?p ?f - object)
  :precondition (and (DATALOG_PASSENGER ?p) (liftat ?f) (not (DATALOG_INCONSISTENT)))
  :effect (and (when (and (origin ?p ?f) (not (boarded ?p)) (not (served ?p))) (boarded ?p)) (when (DATALOG_QUERY0 ?f ?p) (and (served ?p) (not (boarded ?p))))))
(:action moveUp
  :parameters (?f1 ?f2 - object)
  :precondition (and (liftat ?f1) (next ?f1 ?f2) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
(:action moveDown
  :parameters (?f1 ?f2 - object)
  :precondition (and (liftat ?f1) (next ?f2 ?f1) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
)